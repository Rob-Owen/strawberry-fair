{"version":3,"sources":["webpack:///./src/components/calendar/EventFilter.jsx","webpack:///./src/util/dates.js","webpack:///./src/components/calendar/CalendarViewToggle.jsx","webpack:///./src/templates/event-info.jsx","webpack:///./src/util/filters.js","webpack:///./src/components/calendar/EventType.js","webpack:///./src/components/calendar/Upcoming.jsx","webpack:///./src/templates/upcoming-events.jsx","webpack:///./src/components/calendar/getEventList.js"],"names":["EnabledFilterTag","name","remove","className","onClick","DisabledFilterTag","add","EventFilterBlock","filterProps","EventFilterTags","allFilters","activeFilters","addFilter","removeFilter","clearFilters","tags","filter","includes","push","key","filterEvents","events","eventFilters","event","every","eventType","frontmatter","eventTypes","areSameDay","date1","date2","daysMatch","getDate","monthsMatch","getMonth","yearsMatch","getFullYear","areSameMinute","minutesMatch","getMinutes","hoursMatch","getHours","isOnOrAfterDay","baseDate","testDate","basePureDate","toPureDate","getTime","dateTime","Date","CalendarViewToggle","view","Fragment","map","modifier","to","displayStyle","weekday","day","month","year","hour","minute","EventTypeList","EventInfo","image","slug","content","contentComponent","Consumer","value","EventInfoWithContext","isPreview","BodyComponent","HTMLContent","href","slice","download","imageInfo","generateEventSubtitle","data","dateTimeRange","markdownRemark","startDate","startDateTime","endDate","endDateTime","start","toLocaleDateString","provideEnd","toLocaleTimeString","site","subtitle","query","useFilters","filterList","useState","filters","setFilters","filterName","concat","eventTypeList","EventMediaBlock","eventUrl","fields","src","_","get","alt","title","excerpt","EventPanelBlock","NoEventsFoundBlock","Upcoming","UpcomingWithContext","previewEventList","getEventList","eventPanels","length","UpcomingEvents","allMarkdownRemark","edges","tabTitle","nodes","sort","event1","event2","range1","range2","start1","start2","end1"],"mappings":"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","file":"component---src-templates-upcoming-events-jsx-02fd24d0c46ae15dd1b1.js","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\n\nconst EnabledFilterTag = ({name, remove}) => (\n    <a className=\"tag is-primary is-light\" onClick={remove}>{name}</a>\n)\n\nEnabledFilterTag.propTypes = {\n    name: PropTypes.string,\n    remove: PropTypes.func\n}\n\nconst DisabledFilterTag = ({name, add}) => (\n    <a className=\"tag\" onClick={add}>{name}</a>\n)\n\nDisabledFilterTag.propTypes = {\n    name: PropTypes.string,\n    add: PropTypes.func\n}\n\nexport const EventFilterBlock = ({filterProps}) => (\n    <div className=\"panel-block filter\">\n        <EventFilterTags filterProps={filterProps} />\n    </div>\n)\n\nexport const EventFilterTags = ({filterProps: {allFilters, activeFilters, addFilter, removeFilter, clearFilters}}) => {\n    // Construct array of tag objects\n    let tags = []\n    for (const filter of allFilters) {\n        if (activeFilters.includes(filter)) {\n            tags.push(<EnabledFilterTag key={filter} name={filter} remove={removeFilter(filter)} />)\n        } else {\n            tags.push(<DisabledFilterTag key={filter} name={filter} add={addFilter(filter)} />)\n        }\n    }\n\n    return (\n        <span className=\"tags\">\n            <span className=\"tag is-white\">Filters: </span>\n            {tags}\n            <a className=\"tag is-delete\" onClick={clearFilters} />\n        </span>\n    )\n}\n\nEventFilterTags.propTypes = {\n    filterProps: PropTypes.shape({\n        allFilters: PropTypes.arrayOf(PropTypes.string),\n        activeFilters: PropTypes.arrayOf(PropTypes.string),\n        addFilter: PropTypes.func.isRequired,\n        removeFilter: PropTypes.func.isRequired,\n        clearFilters: PropTypes.func.isRequired\n    })\n}\n\nEventFilterBlock.propTypes = EventFilterTags.propTypes\n\n// Function to filter a list of events based on a list of types.\n// We return only events for whom all types in the filter are present.\nexport const filterEvents = (events, eventFilters) => {\n    return events.filter(event => eventFilters.every(eventType => event.frontmatter.eventTypes.includes(eventType)))\n}\n","// Do two dateTimes occur on the same day?\nexport function areSameDay(date1, date2) {\n    const daysMatch = date1.getDate() === date2.getDate()           // Do the days (of the month) match?\n    const monthsMatch = date1.getMonth() === date2.getMonth()       // Do the months match?\n    const yearsMatch = date1.getFullYear() === date2.getFullYear()  // Do the years match?\n    return daysMatch && monthsMatch && yearsMatch                   // Then they render to the same day\n}\n\n// Do two dateTimes occur on the same minute? (Smallest meaningful resolution for events, we've decided)\nexport function areSameMinute(date1, date2) {\n    const minutesMatch = date1.getMinutes() === date2.getMinutes()\n    const hoursMatch = date1.getHours() === date2.getHours()\n    const daysMatch = date1.getDate() === date2.getDate()\n    const monthsMatch = date1.getMonth() === date2.getMonth()\n    const yearsMatch = date1.getFullYear() === date2.getFullYear()\n    return minutesMatch && hoursMatch && daysMatch && monthsMatch && yearsMatch\n}\n\n// Does this date occur on or after the given day?\n// Even if an event took place \"earlier today\", it will still show up\nexport function isOnOrAfterDay(baseDate, testDate) {\n    const basePureDate = toPureDate(baseDate)\n    const testPureDate = toPureDate(testDate)\n\n    return testPureDate.getTime() >= basePureDate.getTime()\n}\n\n// Removes the time part of a Date\nfunction toPureDate(dateTime) {\n    return new Date(dateTime.getFullYear(), dateTime.getMonth(), dateTime.getDate())\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Link } from 'gatsby'\n\nimport { FaCalendar, FaListUl } from 'react-icons/fa'\n\nexport const CalendarViewToggle = ({view}) => (\n    <React.Fragment>\n        {['is-hidden-touch', 'is-hidden-desktop is-centered'].map(modifier => (\n            <div className={`tabs is-boxed ${modifier}`} key={modifier}>\n                <ul>\n                    <li className={view == 'calendar' ? 'is-active' : ''}>\n                        <Link to=\"/calendar\">\n                            <span className=\"icon is-small\"><FaCalendar /></span><h1>Calendar</h1>\n                        </Link>\n                    </li>\n                    <li className={view == 'upcoming' ? 'is-active' : ''}>\n                        <Link to=\"/events\">\n                            <span className=\"icon is-small\"><FaListUl /></span><h1>Events list</h1>\n                        </Link>\n                    </li>\n                </ul>\n            </div>\n        ))}\n    </React.Fragment>\n)\n\nCalendarViewToggle.propTypes = {\n    view: PropTypes.oneOf(['calendar', 'upcoming'])\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { graphql } from 'gatsby'\n\nimport PreviewCompatibleImage from '../components/PreviewCompatibleImage'\nimport { HTMLContent } from '../components/Content'\nimport { site } from '../util/templating'\nimport { areSameDay } from '../util/dates'\nimport { PreviewContext } from '../util/context'\n\n//display style of the event date\nexport const displayStyle = {\n    weekday: \"long\",\n    day: \"numeric\",\n    month: \"long\",\n    year: \"numeric\",\n    hour: \"2-digit\",\n    minute: \"2-digit\"\n}\n\n// List of types shown near top of event\nconst EventTypeList = ({eventTypes}) => {\n    if (eventTypes) {\n        return (\n            <div className=\"tags\">\n                {eventTypes.map(eventType => <span key={eventType} className=\"tag\">{eventType}</span>)}\n            </div>\n        )\n    } else {\n        return null\n    }\n}\n\nEventTypeList.propTypes = {\n    eventTypes: PropTypes.arrayOf(PropTypes.string)\n}\n\n// used by website and CMS previews\nexport const EventInfo = ({image, slug, eventTypes, content, contentComponent}) => (\n    <PreviewContext.Consumer>\n        {value => <EventInfoWithContext isPreview={value} image={image} slug={slug}\n        eventTypes={eventTypes} content={content} contentComponent={contentComponent} />}\n    </PreviewContext.Consumer>\n)\n\nconst EventInfoWithContext = ({isPreview, image, slug, eventTypes, content, contentComponent}) => {\n    const BodyComponent = contentComponent || HTMLContent\n\n    return (\n        <React.Fragment>\n            <EventTypeList eventTypes={eventTypes} />\n            {!isPreview && slug ? (\n                <a className=\"button event-download-button\" href={`/ics${slug.slice(0, -1)}.ics`} download>\n                    Add to Calendar\n                </a>\n            ) : null}\n            <BodyComponent content={content} />\n            <PreviewCompatibleImage imageInfo={image} />\n        </React.Fragment>\n    )\n}\n\nEventInfoWithContext.propTypes = {\n    isPreview: PropTypes.bool,\n    eventTypes: EventTypeList.propTypes.eventTypes,\n    image: PropTypes.object.isRequired,\n    content: PropTypes.string.isRequired,\n    contentComponent: PropTypes.elementType\n}\n\nEventInfo.propTypes = EventInfoWithContext.propTypes\n\nexport const generateEventSubtitle = (data) => {\n    const dateTimeRange = data.markdownRemark.frontmatter.dateTimeRange\n\n    const startDate = new Date(dateTimeRange.startDateTime)\n    const endDate = new Date(dateTimeRange.endDateTime)\n    const start = startDate.toLocaleDateString(\"en-GB\", displayStyle)\n\n    if (!dateTimeRange.provideEnd) {\n        return start\n    } else if (areSameDay(startDate, endDate)) {\n        return start + `–${endDate.toLocaleTimeString(\"en-GB\", {hour: \"2-digit\", minute: \"2-digit\"})}`\n    } else {\n        return start + ` – ${endDate.toLocaleDateString(\"en-GB\", displayStyle)}`\n    }\n    // This allows for events to go on overnight / over multiple days\n}\n\nexport default site(EventInfo, data => ({subtitle: generateEventSubtitle(data)}))\n\nexport const query = graphql`\nquery eventInfoTemplate($id: String!) {\n    markdownRemark(id: { eq: $id }) {\n        ...EventFragment\n    }\n    heroData: allMarkdownRemark(filter: {id: {eq: $id}}) {\n        ...HeroFragment\n    }\n}\n`","import { useState } from 'react'\n\nexport const useFilters = (filterList) => {\n    const [filters, setFilters] = useState([])\n\n    const addFilter = (filterName) => (\n        () => {setFilters(filters.concat(filterName))}\n    )\n\n    const removeFilter = (filterName) => (\n        () => {setFilters(filters.filter(name => name !== filterName))}\n    )\n\n    const clearFilters = () => {\n        setFilters([])\n    }\n\n    return {\n        allFilters: filterList,\n        activeFilters: filters,\n        addFilter: addFilter,\n        removeFilter: removeFilter,\n        clearFilters: clearFilters\n    }\n}\n","// List of allowed event types.\n// IF YOU UPDATE THIS LIST MAKE SURE YOU ALSO UPDATE THE LIST IN static/admin/config.yml\n// THEY MUST ALWAYS BE IDENTICAL\nexport const eventTypeList = [\n    'Benefit gig',\n    'Meeting - Programming',\n    'Meeting - Finance',\n    'Band competition',\n    'Other',\n]\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Link } from 'gatsby'\nimport _ from 'lodash'\n\nimport { HTMLContentSmall } from '../Content'\nimport { eventPropTypeValidator } from '../validators'\nimport { EventFilterBlock, filterEvents } from './EventFilter'\nimport { eventTypeList } from './EventType'\nimport { getEventList } from './getEventList'\nimport { PreviewContext } from '../../util/context'\nimport { useFilters } from '../../util/filters'\nimport { isOnOrAfterDay } from '../../util/dates'\nimport { generateEventSubtitle } from '../../templates/event-info'\n\nexport const EventMediaBlock = ({event}) => {\n    const eventUrl = event.fields.slug\n\n    return (\n    <div className=\"media event\">\n        <div className=\"media-left\">\n            <Link to={eventUrl} className=\"image is-64x64\">\n                {event.frontmatter.image ? <img src={_.get(event.frontmatter.image, 'srcNode.childImageSharp.resize.src', event.frontmatter.image.src)}\n                                                alt={event.frontmatter.image.alt} /> : null}\n            </Link>\n        </div>\n        <div className=\"media-content\">\n            <Link to={eventUrl}>\n                <h2 className=\"title is-4\"><strong>{event.frontmatter.title}</strong></h2>\n                <h3 className=\"subtitle is-5\">{generateEventSubtitle({markdownRemark: event})}</h3>\n            </Link>\n            <HTMLContentSmall className=\"add-margin-top\" content={event.excerpt} />\n        </div>\n    </div>\n    )\n}\n\nconst EventPanelBlock = ({event}) => {\n    return (\n        <div className=\"panel-block\">\n            <EventMediaBlock event={event} />\n        </div>\n    )\n}\n\nconst NoEventsFoundBlock = () => (\n    <div className=\"panel-block\">\n        <div className=\"media\">\n            <div className=\"media-content\">\n                <p><strong>No events match the selected filters.</strong></p>\n            </div>\n        </div>\n    </div>\n)\n\nexport const Upcoming = ({events}) => (  // 'events' is only used if it is a preview, otherwise it uses a static query\n    <PreviewContext.Consumer>\n        {value => <UpcomingWithContext isPreview={value} previewEventList={events} />}\n    </PreviewContext.Consumer>\n)\n\nconst UpcomingWithContext = ({isPreview, previewEventList}) => {\n    const filterProps = useFilters(eventTypeList)\n\n    // Get list of events occurring today or later\n    let events = isPreview ? previewEventList : getEventList()\n    events = events.filter(event => isOnOrAfterDay(new Date(), new Date(event.frontmatter.dateTimeRange.provideEnd ? event.frontmatter.dateTimeRange.endDateTime : event.frontmatter.dateTimeRange.startDateTime)))\n\n    const maxItems = 5\n\n    // Construct array of list elements\n    let eventPanels = filterEvents(events, filterProps.activeFilters).slice(0, maxItems).map(event => <EventPanelBlock key={event.frontmatter.title} event={event} />)\n\n    return (\n        <React.Fragment>\n            <h1 className=\"title\">Upcoming Events</h1>\n            <div className=\"upcoming panel\">\n                <EventFilterBlock filterProps={filterProps} />\n                {eventPanels.length > 0 ? eventPanels : <NoEventsFoundBlock />}\n            </div>\n        </React.Fragment>\n    )\n}\n\nEventMediaBlock.propTypes = {\n    event: eventPropTypeValidator\n}\n\nEventPanelBlock.propTypes = {\n    event: EventMediaBlock.propTypes.event\n}\n\nUpcoming.propTypes = {\n    events: PropTypes.arrayOf(\n        PropTypes.shape({\n            node: eventPropTypeValidator\n        })\n    )\n}\n\nUpcomingWithContext.propTypes = {\n    isPreview: PropTypes.bool.isRequired,\n    previewEventList: Upcoming.propTypes.events\n}\n","import React from 'react'\nimport { graphql } from 'gatsby'\n\nimport { site } from '../util/templating'\nimport { Upcoming } from '../components/calendar/Upcoming'\nimport { CalendarViewToggle } from '../components/calendar/CalendarViewToggle'\n\nexport const UpcomingEvents = ({events}) => {\n  return (\n    <section>\n      <CalendarViewToggle view='upcoming' />\n      <Upcoming events={events} />\n    </section>\n  )\n}\n\nUpcomingEvents.propTypes = {\n  events: Upcoming.propTypes.events\n}\n\nexport default site(UpcomingEvents, data => {return {events: data.allMarkdownRemark.edges, tabTitle: \"Upcoming Events\"}})\n\nexport const query = graphql`\nquery upcomingEventsTemplate($id: String!) {\n  markdownRemark(id: { eq: $id }) {\n    html\n  }\n  allMarkdownRemark(filter: {frontmatter: {templateKey: {eq: \"event-info\"}}}, sort: {fields: frontmatter___dateTimeRange___startDateTime, order: ASC}) {\n    edges {\n      node {\n        ...EventFragment\n      }\n    }\n  }\n  heroData: allMarkdownRemark(filter: {id: {eq: $id}}) {\n    ...HeroFragment\n  }\n}\n`","import { useStaticQuery, graphql } from 'gatsby'\n\nimport { areSameMinute } from '../../util/dates'\n\nexport const getEventList = () => {\n  const { allMarkdownRemark } = useStaticQuery(graphql`\n  query eventList {\n      allMarkdownRemark(filter: {frontmatter: {templateKey: {eq: \"event-info\"}}}, sort: {fields: frontmatter___dateTimeRange___startDateTime, order: ASC}) {\n          nodes {\n              ...EventFragment\n          }\n      }\n  }\n  `)\n\n  // Already started by start time, but if two events start at the same time, we want to sort then by the end time (if provided).\n  const nodesSorted = allMarkdownRemark.nodes.sort((event1, event2) => {\n    const range1 = event1.frontmatter.dateTimeRange\n    const range2 = event2.frontmatter.dateTimeRange\n    const start1 = new Date(range1.startDateTime)\n    const start2 = new Date(range2.startDateTime)\n\n    // Only need to do anything if they start at the same time\n    if (areSameMinute(start1, start2)) {\n      // Four cases, for each combination of each providing or not providing an end time.\n      // We'll deal with them all.\n      if (range1.provideEnd) {\n        const end1 = new Date(range1.endDateTime)\n\n        if (range2.provideEnd) {\n          const end2 = new Date(range2.endDateTime)\n          // Both ends provided, so sort by end date\n          return end1 - end2\n        } else {\n          // Range 2 has no defined end time, so ends first\n          return 1\n        }\n      } else {\n        if (range2.provideEnd) {\n          // Range 1 has no defined end time, so ends first\n          return -1\n        } else {\n          // Neither have a defined end, so they occur at the same time\n          return 0\n        }\n      }\n    } else {\n      // Leave in current order\n      return 0\n    }\n  })\n\n  return nodesSorted\n}\n"],"sourceRoot":""}